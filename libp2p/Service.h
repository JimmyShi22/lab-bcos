/*
    This file is part of cpp-ethereum.

    cpp-ethereum is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    cpp-ethereum is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with cpp-ethereum.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file Service.h
 *  @author molan
 *  @modify first draft
 *  @date 20180910
 *  @author chaychen
 *  @modify realize encode and decode, add timeout, code format
 *  @date 20180911
 */

#pragma once
#include "Host.h"
#include <libdevcore/Common.h>
#include <libdevcore/Exceptions.h>
#include <libdevcore/FixedHash.h>
#include <memory>

namespace dev
{
namespace p2p
{
DEV_SIMPLE_EXCEPTION(NetworkTimeout);
DEV_SIMPLE_EXCEPTION(NetworkUnreachable);
DEV_SIMPLE_EXCEPTION(TopicNotFound);
DEV_SIMPLE_EXCEPTION(NodeIDNotFound);

class Message : std::enable_shared_from_this<Message>
{
public:
    typedef std::shared_ptr<Message> Ptr;

    const static size_t HEADER_LENGTH = sizeof(uint32_t) + sizeof(uint32_t) +
                                        sizeof(uint32_t);  ///< HEADER_LENGTH = length(m_length) +
                                                           ///< length(m_protocolID) + length(m_seq)
    const static size_t MAX_LENGTH = 1024 * 1024 * 1024;   ///< The maximum length of data is 1M.

    Message() { m_buffer = std::make_shared<bytes>(); }

    virtual ~Message() {}

    uint32_t length() { return m_length; }
    void setLength(uint32_t _length) { m_length = _length; }

    uint32_t protocolID() { return m_protocolID; }
    void setProtocolID(uint32_t _protocolID) { m_protocolID = _protocolID; }

    uint32_t seq() { return m_seq; }
    void setSeq(uint32_t _seq) { m_seq = _seq; }

    std::shared_ptr<bytes> buffer() { return m_buffer; }
    void setBuffer(std::shared_ptr<bytes> _buffer) { m_buffer = _buffer; }

    void encode(bytes& buffer)
    {
        uint32_t length = htonl(m_length);
        uint32_t protocolID = htonl(m_protocolID);
        uint32_t seq = htonl(m_seq);

        buffer.insert(buffer.end(), (byte*)&length, (byte*)&length + sizeof(length));
        buffer.insert(buffer.end(), (byte*)&protocolID, (byte*)&protocolID + sizeof(protocolID));
        buffer.insert(buffer.end(), (byte*)&seq, (byte*)&seq + sizeof(seq));
        buffer.insert(buffer.end(), m_buffer->begin(), m_buffer->end());
    }

    ssize_t decode(const byte* buffer, size_t size)
    {
        if (size < HEADER_LENGTH)
        {
            return 0;
        }

        m_length = ntohl(*((uint32_t*)&buffer[0]));

        if (m_length > MAX_LENGTH)
        {
            return -1;
        }

        if (size != m_length)
        {
            return 0;
        }

        m_protocolID = ntohl(*((uint32_t*)&buffer[4]));
        m_seq = ntohl(*((uint32_t*)&buffer[8]));
        m_buffer->assign(&buffer[HEADER_LENGTH], &buffer[HEADER_LENGTH] + m_length - HEADER_LENGTH);

        return m_length;
    }

private:
    uint32_t m_length = 0;      ///< m_length = HEADER_LENGTH + length(m_buffer)
    uint32_t m_protocolID = 0;  ///< message type
    uint32_t m_seq = 0;  ///< The message identify is generated by the client by autoincrement.
    std::shared_ptr<bytes> m_buffer;  ///< message data, RLP encoded
};

struct Options
{
    uint32_t timeout;  /// < The timeout value of async function, in milliseconds.
};

class Service
{
public:
    Message::Ptr sendMessageByNodeID(dev::h256 nodeID, uint32_t protocolID, Message::Ptr message);
    void asyncSendMessageByNodeID(dev::h256 nodeID, uint32_t protocolID, Message::Ptr message,
        std::function<void(dev::Exception, Message::Ptr)> callback, Options options);

    Message::Ptr sendMessageByTopic(std::string topic, uint32_t protocolID, Message::Ptr message);
    void asyncSendMessageByTopic(std::string topic, uint32_t protocolID, Message::Ptr message,
        std::function<void(dev::Exception, Message::Ptr)> callback, Options options);

    void asyncMulticastMessageByTopic(std::string topic, uint32_t protocolID, Message::Ptr message);
    void asyncBroadcastMessage(uint32_t protocolID, Message::Ptr message, Options options);

    void registerHandlerByProtoclID(uint32_t protocolID,
        std::function<void(dev::Exception, std::shared_ptr<Session>, Message::Ptr)> handler);
    void registerHandlerByTopic(std::string topic,
        std::function<void(dev::Exception, std::shared_ptr<Session>, Message::Ptr)> handler,
        Options options){};

private:
    std::shared_ptr<Host> m_host;
    std::unordered_map<uint32_t, std::function<void(dev::Exception, Message::Ptr)> > m_seq2Callback;
    std::unordered_map<uint32_t,
        std::function<void(dev::Exception, std::shared_ptr<Session>, Message::Ptr)> >
        m_protocolID2Handler;
    std::unordered_map<std::string,
        std::function<void(dev::Exception, std::shared_ptr<Session>, Message::Ptr)> >
        m_topic2Handler;
};

}  // namespace p2p

}  // namespace dev
