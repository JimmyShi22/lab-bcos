/*
    This file is part of FISCO-BCOS.

    FISCO-BCOS is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    FISCO-BCOS is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with FISCO-BCOS.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file Service.h
 *  @author molan
 *  @modify first draft
 *  @date 20180910
 *  @author chaychen
 *  @modify realize encode and decode, add timeout, code format
 *  @date 20180911
 */

#pragma once
#include "Host.h"
#include <libdevcore/Common.h>
#include <libdevcore/Exceptions.h>
#include <libdevcore/FixedHash.h>
#include <memory>

namespace dev
{
namespace p2p
{
DEV_SIMPLE_EXCEPTION(NetworkTimeout);
DEV_SIMPLE_EXCEPTION(NetworkUnreachable);
DEV_SIMPLE_EXCEPTION(TopicNotFound);
DEV_SIMPLE_EXCEPTION(NodeIDNotFound);

class Message : std::enable_shared_from_this<Message>
{
public:
    typedef std::shared_ptr<Message> Ptr;

    const static size_t HEADER_LENGTH = sizeof(uint32_t) + sizeof(uint32_t) +
                                        sizeof(uint32_t);  ///< HEADER_LENGTH = length(m_length) +
                                                           ///< length(m_protocolID) + length(m_seq)
    const static size_t MAX_LENGTH = 1024 * 1024;          ///< The maximum length of data is 1M.

    Message() { m_buffer = std::make_shared<bytes>(); }

    virtual ~Message() {}

    uint32_t length() { return m_length; }
    void setLength(uint32_t _length) { m_length = _length; }

    uint32_t protocolID() { return m_protocolID; }
    void setProtocolID(uint32_t _protocolID) { m_protocolID = _protocolID; }

    uint32_t seq() { return m_seq; }
    void setSeq(uint32_t _seq) { m_seq = _seq; }

    std::shared_ptr<bytes> buffer() { return m_buffer; }
    void setBuffer(std::shared_ptr<bytes> _buffer) { m_buffer = _buffer; }

    ///< encoding and decoding logic implemented in send() and doRead() of session.cpp

private:
    uint32_t m_length = 0;      ///< m_length = HEADER_LENGTH + length(m_buffer)
    uint32_t m_protocolID = 0;  ///< message type
    uint32_t m_seq = 0;  ///< The message identify is generated by the client by autoincrement.
    std::shared_ptr<bytes> m_buffer;  ///< message data, RLP encoded
};

struct Options
{
    uint32_t timeout;  /// < The timeout value of async function, in milliseconds.
};

class Service
{
public:
    Message::Ptr sendMessageByNodeID(
        dev::h256 const& nodeID, uint32_t protocolID, Message::Ptr message);

    void asyncSendMessageByNodeID(dev::h256 const& nodeID, uint32_t protocolID,
        Message::Ptr message, std::function<void(dev::Exception, Message::Ptr)> callback,
        Options options);

    Message::Ptr sendMessageByTopic(
        std::string const& topic, uint32_t protocolID, Message::Ptr message);

    void asyncSendMessageByTopic(std::string const& topic, uint32_t protocolID,
        Message::Ptr message, std::function<void(dev::Exception, Message::Ptr)> callback,
        Options options);

    void asyncMulticastMessageByTopic(
        std::string const& topic, uint32_t protocolID, Message::Ptr message);

    void asyncBroadcastMessage(uint32_t protocolID, Message::Ptr message, Options options);

    void registerHandlerByProtoclID(uint32_t protocolID,
        std::function<void(dev::Exception, std::shared_ptr<Session>, Message::Ptr)> handler);

    void registerHandlerByTopic(std::string const& topic,
        std::function<void(dev::Exception, std::shared_ptr<Session>, Message::Ptr)> handler,
        Options options);

private:
    std::shared_ptr<Host> m_host;

    std::unordered_map<uint32_t, std::function<void(dev::Exception, Message::Ptr)> > m_seq2Callback;

    std::unordered_map<uint32_t,
        std::function<void(dev::Exception, std::shared_ptr<Session>, Message::Ptr)> >
        m_protocolID2Handler;

    std::unordered_map<std::string,
        std::function<void(dev::Exception, std::shared_ptr<Session>, Message::Ptr)> >
        m_topic2Handler;
};

}  // namespace p2p

}  // namespace dev
